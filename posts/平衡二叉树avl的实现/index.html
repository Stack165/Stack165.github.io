<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.101.0" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Shuhai" />
  <meta property="og:url" content="https://shuhai65.github.io/posts/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl%E7%9A%84%E5%AE%9E%E7%8E%B0/" />
  <link rel="canonical" href="https://shuhai65.github.io/posts/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl%E7%9A%84%E5%AE%9E%E7%8E%B0/" /><link rel="alternate" type="application/atom+xml" href="https://shuhai65.github.io/index.xml" title="Shuhai&#39;s Blog">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/shuhai65.github.io\/"
      },
      "articleSection" : "posts",
      "name" : "平衡二叉树（AVL）的实现",
      "headline" : "平衡二叉树（AVL）的实现",
      "description" : "平衡二叉树（AVL）的详细(c\u002b\u002b）实现,介绍了二叉排序树和平衡二叉树",
      "inLanguage" : "en-US",
      "author" : "Shuhai",
      "creator" : "Shuhai",
      "publisher": "Shuhai",
      "accountablePerson" : "Shuhai",
      "copyrightHolder" : "Shuhai",
      "copyrightYear" : "2022",
      "datePublished": "2022-01-16 22:43:48 \u002b0000 UTC",
      "dateModified" : "2022-01-16 22:43:48 \u002b0000 UTC",
      "url" : "https:\/\/shuhai65.github.io\/posts\/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91avl%E7%9A%84%E5%AE%9E%E7%8E%B0\/",
      "keywords" : [ "算法","cpp","c", ]
  }
</script>
<title>平衡二叉树（AVL）的实现 - Shuhai&#39;s Blog</title>
  <meta property="og:title" content="平衡二叉树（AVL）的实现 - Shuhai&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="平衡二叉树（AVL）的详细(c&#43;&#43;）实现,介绍了二叉排序树和平衡二叉树" />
  <meta name="description" content="平衡二叉树（AVL）的详细(c&#43;&#43;）实现,介绍了二叉排序树和平衡二叉树" />
  <meta property="og:locale" content="en-us" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/github-markdown.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Shuhai&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  

  
</head>

<body>
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">Shuhai</a>
  </div>
</header>
<div class="row end-xs">
  
  
  <div class="lang-switch col-xs-3 col-xs-offset-9">
    <a href="/en/">English</a>
  </div>
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">平衡二叉树（AVL）的实现</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2022-01-16 22:43:48 UTC">
                16 Jan 2022
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://shuhai65.github.io/">@Shuhai</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <h1 id="平衡二叉树概念">平衡二叉树概念</h1>
<blockquote>
<p>平衡二叉排序树（Balanced Binary Tree），因由前苏联数学家Adelson-Velskii 和
Landis于1962年首先提出的，所以又称为AVL树。</p>
</blockquote>
<p>平衡二叉树是一种特殊的二叉排序树，理解平衡二叉树首先要理解什么是二叉排序树。
如果已经了解二叉排序树可以直接看下面平衡二叉树内容。</p>
<h1 id="二叉排序树binary-sort-tree">二叉排序树（Binary Sort Tree）</h1>
<p>所谓二叉排序树(BST)即：
（1）若该树的<strong>左</strong>子树不为空，那么<strong>左</strong>子树所有结点的值均<strong>小</strong>于其根结点的值。
（2）若该树的<strong>右</strong>子树不为空，那么<strong>右</strong>子树所有结点的值均<strong>大</strong>于其根结点的值。
（3）该树的左右子树也均为二叉排序树。
依此定义，我们可以通过比较根结点的值一层层地定位到所要查找的值。</p>
<p>例：如下图是一棵二叉排序树
<img src="https://s1.ax1x.com/2023/03/28/ppcPf0I.png" alt="1">
比如我们要查找7，那么先从根结点开始比较，8&gt;7查找左子树 <strong>&mdash;-&gt;</strong> 3&lt;7查找右子树 <strong>&mdash;-&gt;</strong> 6&gt;7查找右子树 <strong>&mdash;-&gt;</strong> 最后7=7，找到了7。
这种查找算法与折半查找相似，也是逐步缩小搜索范围。
若中序遍历上图，则可以得到一个按数值大小排序的递增序列：1，3，4，6，7，8，10，13，15。</p>
<h2 id="二叉排序树的储存结构">二叉排序树的储存结构</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BSTNode</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> data<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//数据项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BSTNode</span> <span style="color:#f92672">*</span>lchild<span style="color:#f92672">=</span>NULL,<span style="color:#f92672">*</span>rchild<span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//左右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}BSTNode,<span style="color:#f92672">*</span>BSTree.
</span></span></code></pre></div><h2 id="二叉排序树的查找算法递归查找">二叉排序树的查找算法（递归查找）</h2>
<p>BSTree T 为二叉树根节点 ，int e 为查找的关键字。时间复制度为O(log2 n)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">searchTree</span>(BSTree T,<span style="color:#66d9ef">int</span> e)<span style="color:#75715e">//在二叉树中查找给定关键字(函数返回值为成功1,失败0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (T<span style="color:#f92672">==</span>NULL)<span style="color:#75715e">//无法查找到给定关键字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">==</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//查找到关键字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//小于根结点，向左子树查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> searchTree(T<span style="color:#f92672">-&gt;</span>lchild,e);
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(e<span style="color:#f92672">&gt;</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//大于根结点，向右子树查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> searchTree(T<span style="color:#f92672">-&gt;</span>rchild,e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="二叉排序树的创建及插入递归">二叉排序树的创建及插入（递归）</h2>
<p>二叉排序树的插入算法基本过程也是查找，时间复制度也为O(log2 n)。
<img src="https://s1.ax1x.com/2023/03/28/ppcPItf.png" alt="2"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InsertBST</span>(BSTree <span style="color:#f92672">&amp;</span>T,<span style="color:#66d9ef">int</span> e)<span style="color:#75715e">//插入节点，根据节点值的大小插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{<span style="color:#75715e">//当二叉排序树中不存在关键字等于e的结点时，查找结束，插入结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T)<span style="color:#75715e">//查找到插入位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        BSTNode <span style="color:#f92672">*</span>S; <span style="color:#75715e">//生成新结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        S<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> BSTNode;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>e;<span style="color:#75715e">//给新结点赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        S<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>S<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//将新结点作为叶子结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        T<span style="color:#f92672">=</span>S;<span style="color:#75715e">//给查找到的插入位置赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        InsertBST(T<span style="color:#f92672">-&gt;</span>lchild,e);<span style="color:#75715e">//向左查找插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&gt;</span>T<span style="color:#f92672">-&gt;</span>data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        InsertBST(T<span style="color:#f92672">-&gt;</span>rchild,e);<span style="color:#75715e">//向右查找插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">CreatBST</span>(BSTree <span style="color:#f92672">&amp;</span>T)<span style="color:#75715e">//创建二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> e,n,i;
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        InsertBST(T,e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="平衡二叉树">平衡二叉树</h1>
<p>介绍完二叉排序树，我们就来看看平衡二叉树。
平衡二叉树就是在二叉排序树上建立的，可以说是具有以下两个特征的二叉排序树：
（1）左子树和右子树的深度之差的绝对值不超过1。
（2）左子树和右子树也是平衡二叉树。</p>
<h2 id="平衡因子">平衡因子</h2>
<p>为了方便记录和计算左右子树深度之差，我们引入一个概念叫平衡因子。
平衡因子就是该结点左右子树深度之差，由平衡二叉树的定义我们可以知道平衡二叉树上的平衡因子只可能是-1，0，1 。
<img src="https://s1.ax1x.com/2023/03/28/ppcPh7t.png" alt="3"></p>
<h2 id="二叉排序树的储存结构-1">二叉排序树的储存结构</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//结点值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> depth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//深度，方便通过计算左右子树深度之差得到该结点的平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span> <span style="color:#f92672">*</span>father<span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//父结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span> <span style="color:#f92672">*</span>lchild<span style="color:#f92672">=</span>NULL,<span style="color:#f92672">*</span>rchild<span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//左右结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} AVLNode,<span style="color:#f92672">*</span>AVLTree; <span style="color:#75715e">//结点结构体
</span></span></span></code></pre></div><p><strong>计算平衡因子代码实现：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count_depth</span>(AVLTree <span style="color:#f92672">&amp;</span>T)<span style="color:#75715e">//计算各结点的深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span>count_depth(T<span style="color:#f92672">-&gt;</span>lchild);<span style="color:#75715e">//左子树深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span>count_depth(T<span style="color:#f92672">-&gt;</span>rchild);<span style="color:#75715e">//右子树深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> T<span style="color:#f92672">-&gt;</span>depth<span style="color:#f92672">=</span>max(l,r)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//更新深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_balance</span>(AVLTree T)<span style="color:#75715e">//读取深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> T<span style="color:#f92672">-&gt;</span>depth;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count_balance</span>(AVLTree T)<span style="color:#75715e">//计算平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>T)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> get_balance(T<span style="color:#f92672">-&gt;</span>lchild)<span style="color:#f92672">-</span>get_balance(T<span style="color:#f92672">-&gt;</span>rchild);<span style="color:#75715e">//平衡因子等于左右子树的深度之差
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="平衡二叉树的创建及调整方法">平衡二叉树的创建及调整方法</h2>
<p>如何创建一棵平衡二叉树呢？
简单的来说就是：
（1）<strong>先</strong>按照我们创建二叉排序树的方法，找到结点插入位置，将结点插入二叉树中。</p>
<p>（2）<strong>然后</strong>我们来计算该插入结点父结点的平衡因子， <strong>如果平衡因子绝对值大于1，代表该子树是不平衡的，那么对该子树进行调整，将其调整为平衡二叉树</strong>， 然后一层一层往上计算平衡因子和进行调整，直到根节点（根结点平衡因子绝对值大于1也要调整），最终把整棵树调整为平衡二叉树。</p>
<p>（3）第三步就重复上面操作，把一个一个结点插入二叉树中并进行调整，最终插入完所有结点并创建完成平衡二叉树。</p>
<p><img src="https://s1.ax1x.com/2023/03/28/ppcPoh8.png" alt="4"></p>
<h2 id="平衡二叉树的调整">平衡二叉树的调整</h2>
<p>平衡二叉树的调整有4种调整情况。</p>
<blockquote>
<p>这里有一篇写得比较好的文章可以参考一下：<a href="https://blog.csdn.net/u014634338/article/details/42465089">平衡二叉树（AVL）图解与实现-zthgreat
</a></p>
</blockquote>
<h3 id="ll型">LL型</h3>
<p><code>(a)</code> 图a中我们插入“16” 后计算平衡因子发现结点“31”的平衡因子为2，该树为非平衡树，需要进行调整，我们<code>以结点“25”为旋转中心</code>，将其<code>父结点</code>按<code>顺时针旋转</code>为其<code>右子树</code>，至此该树调整完毕。
<code>注意</code>：25的左结点16不进行旋转。
<code> (b)</code> 图b中我们插入“9”后计算平衡因子发现结点“31”的平衡因子为2，该树为非平衡树，需要进行调整，我们<code>以结点“25”为旋转中心</code>，将其<code>父结点“31”</code>按<code>顺时针旋转</code>为其<code>右子树</code>，再把<code>旋转中心“25”的右子树</code>调整为<code>31</code>的左子树，至此该树调整完毕。</p>
<p><img src="https://s1.ax1x.com/2023/03/28/ppcP5AP.png" alt="5"></p>
<p>   我们总结出以下<code>规律</code>（参考下图）：将<code>B</code>结点作为根结点，<code>A</code>结点旋转为<code>B</code>结点的右子树，再把<code>B</code>结点本来的右子树连接为<code>A</code>结点的左子树，该树调整完成。
<img src="https://s1.ax1x.com/2023/03/28/ppcP79S.png" alt="6">
代码实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">LL_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLTree parent<span style="color:#f92672">=</span>NULL,son;<span style="color:#75715e">//son结点即为旋转中心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>father;<span style="color:#75715e">//获取失衡结点的父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>lchild;<span style="color:#75715e">//获取失衡结点的左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (son<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">!=</span>NULL)<span style="color:#75715e">//设置son结点右孩子的父指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        son<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>T;
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>son<span style="color:#f92672">-&gt;</span>rchild;<span style="color:#75715e">//失衡结点的左孩子变更为son的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//T的子结点更新完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(T);<span style="color:#75715e">//更新失衡结点的深度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>T;<span style="color:#75715e">//失衡结点变成son的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>parent;<span style="color:#75715e">//设置son的父结点为原失衡结点的父结点，连接整颗树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果失衡结点不是根结点，则更新父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">==</span>T)
</span></span><span style="display:flex;"><span>            parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">//父节点的右孩子是失衡结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            parent<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>son;<span style="color:#75715e">//设置失衡结点的父亲
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(son);<span style="color:#75715e">//更新son结点的高度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> son;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="rr型">RR型</h3>
<p><img src="https://s1.ax1x.com/2023/03/28/ppcPH1g.png" alt="7">
<code>(a)</code> 图a中我们插入“69” 后计算平衡因子发现结点“31”的平衡因子为-2，该树为非平衡树，需要进行调整，我们<code>以结点“47”为旋转中心</code>，将其<code>父结点</code>按<code>逆时针旋转</code>为其<code>左子树</code>，至此该树调整完毕。
<code>注意</code>：47的右结点69不进行旋转。
<code> (b)</code> 图b中我们插入“76”后计算平衡因子发现结点“31”的平衡因子为2，该树为非平衡树，需要进行调整，我们<code>以结点“47”为旋转中心</code>，将其<code>父结点“31”</code>按<code>逆时针旋转</code>为其<code>左子树</code>，再把<code>旋转中心“47”的左子树</code>调整为<code>31</code>的右子树，至此该树调整完毕。</p>
<p>   我们总结出以下<code>规律</code>（参考下图）：将<code>B</code>结点作为根结点，<code>A</code>结点旋转为<code>B</code>结点的左子树，再把<code>B</code>结点本来的左子树连接为<code>A</code>结点的右子树，该树调整完成。
   可以看到LL型调整和RR型是左右相反的调整。
<img src="https://s1.ax1x.com/2023/03/28/ppcPbcQ.png" alt="8">
代码实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">RR_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLTree parent<span style="color:#f92672">=</span>NULL,son;<span style="color:#75715e">//son结点即为旋转中心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>father;<span style="color:#75715e">//获取失衡结点的父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>rchild;<span style="color:#75715e">//获取失衡结点的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (son<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">!=</span>NULL)<span style="color:#75715e">//设置son结点左孩子的父指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        son<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>T;
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>son<span style="color:#f92672">-&gt;</span>lchild;<span style="color:#75715e">//失衡结点的右孩子变更为son的左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//T的子结点更新完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(T);<span style="color:#75715e">//更新失衡结点的高度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>T;<span style="color:#75715e">//失衡结点变成son的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>parent;<span style="color:#75715e">//设置son的父结点为原失衡结点的父结点，连接整颗树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果失衡结点不是根结点，则更新父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">==</span>T)
</span></span><span style="display:flex;"><span>            parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">//父节点的右孩子是失衡结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            parent<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>son;<span style="color:#75715e">//设置失衡结点的父亲
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(son);<span style="color:#75715e">//更新son结点的高度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> son;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="3-lr型">(3) LR型</h3>
<p><img src="https://s1.ax1x.com/2023/03/28/ppcPXBn.png" alt="9">
<code>(a)</code> 图a中我们插入“28” 后计算平衡因子发现结点“31”的平衡因子为2，该树为非平衡树，需要进行调整。
(1)我们对25和28进行RR型旋转调整<code>以结点“28”为旋转中心</code>，将其<code>父结点25</code>按<code>逆时针旋转</code>为其<code>左子树</code>，再连接为31的左子树。
(2)观察到调整后的树是LL型，故<code>以结点“28”为旋转中心</code>，将其<code>父结点31</code>按<code>顺时针旋转</code>为其<code>右子树</code>，调整完毕。
<img src="https://s1.ax1x.com/2023/03/28/ppcPqXj.jpg" alt="10"></p>
<p><code> (b)</code> 图b中我们插入“26” 后计算平衡因子发现结点“31”的平衡因子为2，该树为非平衡树，需要进行调整。
(1)我们对25和28进行RR型旋转调整<code>以结点“28”为旋转中心</code>，将其<code>父结点25</code>按<code>逆时针旋转</code>为其<code>左子树</code>，<code>“28”的左子树“26”</code>连接为“25”的右子树，再将&quot;28&quot;连接为&quot;31&quot;的左子树。
(2)观察到调整后的树是LL型，故<code>以结点“28”为旋转中心</code>，将其<code>父结点31</code>按<code>顺时针旋转</code>为其<code>右子树</code>，调整完毕。
<img src="https://s1.ax1x.com/2023/03/28/ppciShT.jpg" alt="11">
<code>(c)</code>图b中我们插入“30” 后计算平衡因子发现结点“31”的平衡因子为2，该树为非平衡树，需要进行调整。
(1)我们对25和28进行RR型旋转调整<code>以结点“28”为旋转中心</code>，将其<code>父结点25</code>按<code>逆时针旋转</code>为其<code>左子树</code>，再将&quot;28&quot;连接为&quot;31&quot;的左子树。
(2)观察到调整后的树是LL型，故<code>以结点“28”为旋转中心</code>，将其<code>父结点31</code>按<code>顺时针旋转</code>为其<code>右子树</code>，再将“28”（旋转中心）的右子树“30”连接为“31”的左子树，调整完毕。
<img src="https://s1.ax1x.com/2023/03/28/ppcPxA0.jpg" alt="12"></p>
<p>  <strong>我们总结出以下<code>规律</code></strong>（参考下图）：LR型<strong>先对B,C进行RR型旋转</strong>(以B为旋转中心)，旋转后就变成LL型的非平衡树之后<strong>再对A，B，C进行LL型旋转调整</strong>(以B为旋转中心)。
<img src="https://s1.ax1x.com/2023/03/28/ppcPj7q.png" alt="13">
代码实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">LR_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    RR_rotate(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> LL_rotate(T);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="4-rl型">(4) RL型</h3>
<p><img src="https://s1.ax1x.com/2023/03/28/ppciC3F.png" alt="14">
RL型就与LR型相反，先进行LL型旋转，再进行RR型旋转。如（a）图的旋转。
<img src="https://s1.ax1x.com/2023/03/28/ppci99U.jpg" alt="15">
  <strong>我们总结出以下<code>规律</code></strong>（参考下图）：RL型<strong>先对B,C进行LL型旋转</strong>(以B为旋转中心)，旋转后就变成RR型的非平衡树之后<strong>再对A，B，C进行RR型旋转调整</strong>(以B为旋转中心)。
<img src="https://s1.ax1x.com/2023/03/28/ppciPc4.png" alt="16">
代码实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">RL_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LL_rotate(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> RR_rotate(T);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="平衡二叉树的创建">平衡二叉树的创建</h3>
<p>了解完了如何调整非平衡二叉树，剩下工作就比较简单了，无非是在创建二叉排序树时，每次插入结点，把二叉树调整为平衡二叉树。
下面是代码实现：</p>
<h4 id="输入数据">输入数据</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">creativetree</span>(AVLTree <span style="color:#f92672">&amp;</span>T)<span style="color:#75715e">//输入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> e,n,i;
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        T<span style="color:#f92672">=</span>Insert(T,e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="插入数据">插入数据</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">InsertAVL</span>(AVLTree <span style="color:#f92672">&amp;</span>T,<span style="color:#66d9ef">int</span> e,AVLTree parent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T)<span style="color:#75715e">//找到结点插入位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        AVLNode <span style="color:#f92672">*</span>S;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> AVLNode;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>e;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>parent;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>S<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>        T<span style="color:#f92672">=</span>S;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> S;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//向左搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> InsertAVL(T<span style="color:#f92672">-&gt;</span>lchild,e,T);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&gt;</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//向右搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> InsertAVL(T<span style="color:#f92672">-&gt;</span>rchild,e,T);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;<span style="color:#75715e">//该结点已存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">Insert</span>(AVLTree <span style="color:#f92672">&amp;</span>T,<span style="color:#66d9ef">int</span> e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLNode <span style="color:#f92672">*</span>S;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> AVLNode;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">=</span>InsertAVL(T,e,NULL);<span style="color:#75715e">//插入结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(T);<span style="color:#75715e">//更新深度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    T<span style="color:#f92672">=</span>AVLchange(T,S);<span style="color:#75715e">//调整为平衡二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> T;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="调整平衡二叉树">调整平衡二叉树</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">AVLchange</span>(AVLTree <span style="color:#f92672">&amp;</span>T,AVLTree S)<span style="color:#75715e">//调整为平衡二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> balance<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (S)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        count_depth(T);<span style="color:#75715e">//计算深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        balance<span style="color:#f92672">=</span>count_balance(S);<span style="color:#75715e">//计算平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(balance<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">||</span>balance<span style="color:#f92672">&lt;-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(balance<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//L型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(count_balance(S<span style="color:#f92672">-&gt;</span>lchild)<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//LL型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    S<span style="color:#f92672">=</span>LL_rotate(S);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>  <span style="color:#75715e">//LR型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    S<span style="color:#f92672">=</span>LR_rotate(S);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(balance<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//R型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (count_balance(S<span style="color:#f92672">-&gt;</span>rchild)<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e">//RR型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    S<span style="color:#f92672">=</span>RR_rotate(S);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#75715e">//RL型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    S<span style="color:#f92672">=</span>RL_rotate(S);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(S<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">==</span>NULL)<span style="color:#75715e">//到达根节点，退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                T<span style="color:#f92672">=</span>S;<span style="color:#75715e">//更新为新的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">=</span>S<span style="color:#f92672">-&gt;</span>father;<span style="color:#75715e">//一层一层往上调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> T;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="平衡二叉树实现的整体代码">平衡二叉树实现的整体代码</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stdio.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;malloc.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> data<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//结点值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> depth<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span> <span style="color:#f92672">*</span>father<span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//父结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AVLNode</span> <span style="color:#f92672">*</span>lchild<span style="color:#f92672">=</span>NULL,<span style="color:#f92672">*</span>rchild<span style="color:#f92672">=</span>NULL;<span style="color:#75715e">//左右结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} AVLNode,<span style="color:#f92672">*</span>AVLTree; <span style="color:#75715e">//结点结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count_depth</span>(AVLTree <span style="color:#f92672">&amp;</span>T)<span style="color:#75715e">//计算各结点的深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T<span style="color:#f92672">==</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span>count_depth(T<span style="color:#f92672">-&gt;</span>lchild);<span style="color:#75715e">//左子树深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span>count_depth(T<span style="color:#f92672">-&gt;</span>rchild);<span style="color:#75715e">//右子树深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> T<span style="color:#f92672">-&gt;</span>depth<span style="color:#f92672">=</span>max(l,r)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//更新深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_balance</span>(AVLTree T)<span style="color:#75715e">//读取深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(T)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> T<span style="color:#f92672">-&gt;</span>depth;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count_balance</span>(AVLTree T)<span style="color:#75715e">//计算平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>T)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> get_balance(T<span style="color:#f92672">-&gt;</span>lchild)<span style="color:#f92672">-</span>get_balance(T<span style="color:#f92672">-&gt;</span>rchild);<span style="color:#75715e">//平衡因子等于左右子树的深度之差
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">LL_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLTree parent<span style="color:#f92672">=</span>NULL,son;<span style="color:#75715e">//son结点即为旋转中心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>father;<span style="color:#75715e">//获取失衡结点的父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>lchild;<span style="color:#75715e">//获取失衡结点的左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (son<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">!=</span>NULL)<span style="color:#75715e">//设置son结点右孩子的父指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        son<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>T;
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>son<span style="color:#f92672">-&gt;</span>rchild;<span style="color:#75715e">//失衡结点的左孩子变更为son的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//T的子结点更新完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(T);<span style="color:#75715e">//更新失衡结点的深度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>T;<span style="color:#75715e">//失衡结点变成son的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>parent;<span style="color:#75715e">//设置son的父结点为原失衡结点的父结点，连接整颗树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果失衡结点不是根结点，则更新父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">==</span>T)
</span></span><span style="display:flex;"><span>            parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">//父节点的右孩子是失衡结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            parent<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>son;<span style="color:#75715e">//设置失衡结点的父亲
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(son);<span style="color:#75715e">//更新son结点的高度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> son;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">RR_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLTree parent<span style="color:#f92672">=</span>NULL,son;<span style="color:#75715e">//son结点即为旋转中心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    parent<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>father;<span style="color:#75715e">//获取失衡结点的父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">=</span>T<span style="color:#f92672">-&gt;</span>rchild;<span style="color:#75715e">//获取失衡结点的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (son<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">!=</span>NULL)<span style="color:#75715e">//设置son结点左孩子的父指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        son<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>T;
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>son<span style="color:#f92672">-&gt;</span>lchild;<span style="color:#75715e">//失衡结点的右孩子变更为son的左孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//T的子结点更新完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(T);<span style="color:#75715e">//更新失衡结点的高度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>T;<span style="color:#75715e">//失衡结点变成son的右孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    son<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>parent;<span style="color:#75715e">//设置son的父结点为原失衡结点的父结点，连接整颗树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果失衡结点不是根结点，则更新父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">!=</span>NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">==</span>T)
</span></span><span style="display:flex;"><span>            parent<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#75715e">//父节点的右孩子是失衡结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            parent<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>son;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>son;<span style="color:#75715e">//设置失衡结点的父亲
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(son);<span style="color:#75715e">//更新son结点的高度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> son;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">LR_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    RR_rotate(T<span style="color:#f92672">-&gt;</span>lchild);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> LL_rotate(T);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">RL_rotate</span>(AVLTree T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    LL_rotate(T<span style="color:#f92672">-&gt;</span>rchild);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> RR_rotate(T);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">AVLchange</span>(AVLTree <span style="color:#f92672">&amp;</span>T,AVLTree S)<span style="color:#75715e">//调整为平衡二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> balance<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (S)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        count_depth(T);<span style="color:#75715e">//计算深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        balance<span style="color:#f92672">=</span>count_balance(S);<span style="color:#75715e">//计算平衡因子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(balance<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">||</span>balance<span style="color:#f92672">&lt;-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(balance<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//L型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(count_balance(S<span style="color:#f92672">-&gt;</span>lchild)<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//LL型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    S<span style="color:#f92672">=</span>LL_rotate(S);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>  <span style="color:#75715e">//LR型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    S<span style="color:#f92672">=</span>LR_rotate(S);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(balance<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//R型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (count_balance(S<span style="color:#f92672">-&gt;</span>rchild)<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) <span style="color:#75715e">//RR型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    S<span style="color:#f92672">=</span>RR_rotate(S);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#75715e">//RL型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    S<span style="color:#f92672">=</span>RL_rotate(S);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(S<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">==</span>NULL)<span style="color:#75715e">//到达根节点，退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            {
</span></span><span style="display:flex;"><span>                T<span style="color:#f92672">=</span>S;<span style="color:#75715e">//更新为新的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">=</span>S<span style="color:#f92672">-&gt;</span>father;<span style="color:#75715e">//一层一层往上调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> T;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">InsertAVL</span>(AVLTree <span style="color:#f92672">&amp;</span>T,<span style="color:#66d9ef">int</span> e,AVLTree parent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>T)<span style="color:#75715e">//找到结点插入位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        AVLNode <span style="color:#f92672">*</span>S;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> AVLNode;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">=</span>e;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>father<span style="color:#f92672">=</span>parent;
</span></span><span style="display:flex;"><span>        S<span style="color:#f92672">-&gt;</span>lchild<span style="color:#f92672">=</span>S<span style="color:#f92672">-&gt;</span>rchild<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>        T<span style="color:#f92672">=</span>S;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> S;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//向左搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> InsertAVL(T<span style="color:#f92672">-&gt;</span>lchild,e,T);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (e<span style="color:#f92672">&gt;</span>T<span style="color:#f92672">-&gt;</span>data)<span style="color:#75715e">//向右搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> InsertAVL(T<span style="color:#f92672">-&gt;</span>rchild,e,T);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL;<span style="color:#75715e">//该结点已存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>AVLTree <span style="color:#a6e22e">Insert</span>(AVLTree <span style="color:#f92672">&amp;</span>T,<span style="color:#66d9ef">int</span> e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLNode <span style="color:#f92672">*</span>S;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> AVLNode;
</span></span><span style="display:flex;"><span>    S<span style="color:#f92672">=</span>InsertAVL(T,e,NULL);<span style="color:#75715e">//插入结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    count_depth(T);<span style="color:#75715e">//更新深度信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    T<span style="color:#f92672">=</span>AVLchange(T,S);<span style="color:#75715e">//调整为平衡二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> T;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">creativetree</span>(AVLTree <span style="color:#f92672">&amp;</span>T)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">=</span>NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> e,n,i;
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>e);
</span></span><span style="display:flex;"><span>        T<span style="color:#f92672">=</span>Insert(T,e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    AVLTree T;
</span></span><span style="display:flex;"><span>    creativetree(T);<span style="color:#75715e">//建树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p><code>平衡二叉树的删除操作和其他遍历操作与二叉排序树无异</code>，其他操作可以参考这里<a href="https://blog.csdn.net/Tree_sea/article/details/117571736"> 实现二叉排序树的各种算法</a></p>
</blockquote>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-category">
              <a href="//categories/%e7%ae%97%e6%b3%95/">
                算法
              </a>
            </div>
            
          </div>
        </div>
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        
        

        
        
        <div style="height: 50px;"></div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="/index.xml" target="_blank">RSS</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://shuhai65.github.io/posts/about/" target="_blank">About</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/shuhai65" target="_blank">Github</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

</body>

</html>